name: Deploy AI Demo (auto EC2 + ECR + SSM)

on:
  push:
    branches: [ main ]

env:
  IMAGE_NAME: ai-demo
  CONTAINER_NAME: ai-demo
  APP_TAG_KEY: App
  APP_TAG_VALUE: ai-demo
  PORT: "80"
  STACK_NAME: ai-demo-ec2

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Compute metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          echo "TAG=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "ECR_REGISTRY=$ACCOUNT_ID.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com" >> $GITHUB_OUTPUT
          echo "ECR_URI=$ACCOUNT_ID.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

      - name: Ensure ECR repository
        shell: bash
        run: |
          set -euo pipefail
          aws ecr describe-repositories --repository-names "${{ env.IMAGE_NAME }}" >/dev/null 2>&1 || \
          aws ecr create-repository --repository-names "${{ env.IMAGE_NAME }}" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256 >/dev/null

      - name: Login to ECR
        shell: bash
        run: |
          aws ecr get-login-password | docker login --username AWS --password-stdin "${{ steps.meta.outputs.ECR_REGISTRY }}"

      - name: Build image
        shell: bash
        run: |
          docker build -t "${{ steps.meta.outputs.ECR_URI }}:${{ steps.meta.outputs.TAG }}" \
                       -t "${{ steps.meta.outputs.ECR_URI }}:latest" .

      - name: Push image
        shell: bash
        run: |
          docker push "${{ steps.meta.outputs.ECR_URI }}:${{ steps.meta.outputs.TAG }}"
          docker push "${{ steps.meta.outputs.ECR_URI }}:latest"

      - name: Discover default VPC + a public subnet
        id: net
        shell: bash
        run: |
          set -euo pipefail
          VPC=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)
          if [ -z "$VPC" ] || [ "$VPC" = "None" ]; then echo "No default VPC found"; exit 1; fi
          SUBNET=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC Name=map-public-ip-on-launch,Values=true \
                    --query 'Subnets[0].SubnetId' --output text)
          if [ -z "$SUBNET" ] || [ "$SUBNET" = "None" ]; then
            SUBNET=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC \
                      --query 'Subnets[0].SubnetId' --output text)
          fi
          if [ -z "$SUBNET" ] || [ "$SUBNET" = "None" ]; then echo "Could not find a subnet in VPC $VPC"; exit 1; fi
          echo "VPC=$VPC" >> $GITHUB_OUTPUT
          echo "SUBNET=$SUBNET" >> $GITHUB_OUTPUT

      - name: Create/Update EC2 via CloudFormation
        shell: bash
        run: |
          set -euo pipefail
          aws cloudformation deploy \
            --stack-name "${{ env.STACK_NAME }}" \
            --template-file cfn/ec2-ssm-ecr.yml \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides VpcId=${{ steps.net.outputs.VPC }} SubnetId=${{ steps.net.outputs.SUBNET }} AppTagValue=${{ env.APP_TAG_VALUE }} InstanceType=t2.micro

      - name: Discover instance by tag (running only)
        id: discover
        shell: bash
        run: |
          set -euo pipefail
          ID=$(aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
                      "Name=tag:${{ env.APP_TAG_KEY }},Values=${{ env.APP_TAG_VALUE }}" \
            --query 'Reservations[].Instances[].InstanceId' --output text | head -n1)
          if [ -z "$ID" ] || [ "$ID" = "None" ]; then echo "No running instance found"; exit 1; fi
          echo "INSTANCE_ID=$ID" >> $GITHUB_OUTPUT
          IP=$(aws ec2 describe-instances --instance-ids "$ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "PUBLIC_IP=$IP" >> $GITHUB_OUTPUT
          echo "Instance: $ID  IP: $IP"

      - name: Wait for SSM Online
        shell: bash
        run: |
          set -euo pipefail
          ID="${{ steps.discover.outputs.INSTANCE_ID }}"
          for i in {1..40}; do
            PING=$(aws ssm describe-instance-information \
              --filters Key=InstanceIds,Values="$ID" \
              --query 'InstanceInformationList[0].PingStatus' --output text 2>/dev/null || true)
            echo "PingStatus: $PING"
            if [ "$PING" = "Online" ]; then exit 0; fi
            sleep 6
          done
          echo "Instance not Online in SSM"; exit 1

      - name: Deploy via SSM (install docker + run container)
        shell: bash
        run: |
          set -euo pipefail
          REGION="${{ secrets.AWS_REGION }}"
          ECR_REG="${{ steps.meta.outputs.ECR_REGISTRY }}"
          ECR_URI="${{ steps.meta.outputs.ECR_URI }}"
          ID="${{ steps.discover.outputs.INSTANCE_ID }}"

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy ${ECR_URI}:latest" \
            --parameters commands="[
              \\"set -e\\",
              \\"export AWS_DEFAULT_REGION=$REGION\\",
              \\"if ! command -v docker >/dev/null 2>&1; then sudo dnf -y update || sudo yum -y update; if command -v dnf >/dev/null 2>&1; then sudo dnf -y install docker; else sudo yum -y install docker; fi; sudo systemctl enable --now docker; fi\\",
              \\"aws ecr get-login-password | sudo docker login --username AWS --password-stdin $ECR_REG\\",
              \\"sudo systemctl start docker || true\\",
              \\"sudo docker pull $ECR_URI:latest\\",
              \\"sudo docker rm -f ${CONTAINER_NAME} || true\\",
              \\"sudo docker run -d --name ${CONTAINER_NAME} -p ${PORT}:8080 $ECR_URI:latest\\",
              \\"curl -s http://localhost/health || true\\"
            ]" \
            --query 'Command.CommandId' --output text)
          echo "CMD_ID=$CMD_ID"

          for i in {1..40}; do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[0].Status' --output text 2>/dev/null || true)
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then break; fi
            if echo "$STATUS" | grep -E -q 'Cancelled|Failed|TimedOut'; then
              echo "SSM command failed: $STATUS"; exit 1
            fi
            sleep 5
          done

      - name: External health check
        shell: bash
        run: |
          set -euo pipefail
          IP="${{ steps.discover.outputs.PUBLIC_IP }}"
          for i in {1..30}; do
            CODE=$(curl -s -o /dev/null -w '%{http_code}' "http://$IP/health" || true)
            echo "health http_code=$CODE"
            if [ "$CODE" = "200" ]; then
              echo "APP_URL=http://$IP" >> $GITHUB_OUTPUT
              exit 0
            fi
            sleep 3
          done
          echo "Service not healthy on $IP"; exit 1

      - name: Show app URL
        shell: bash
        run: echo "App disponible en: http://${{ steps.discover.outputs.PUBLIC_IP }}/"
