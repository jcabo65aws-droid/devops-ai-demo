name: Deploy AI Demo (auto EC2 + ECR + SSM)

on:
  push:
    branches: [ main ]

env:
  IMAGE_NAME: ai-demo
  CONTAINER_NAME: ai-demo
  APP_TAG_KEY: App
  APP_TAG_VALUE: ai-demo
  PORT: "80"
  STACK_NAME: ai-demo-ec2

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Configure AWS credentials
        uses: aws-actions/configure-aws-credentials@v4
        with:
          aws-access-key-id: ${{ secrets.AWS_ACCESS_KEY_ID }}
          aws-secret-access-key: ${{ secrets.AWS_SECRET_ACCESS_KEY }}
          aws-region: ${{ secrets.AWS_REGION }}

      - name: Compute metadata
        id: meta
        shell: bash
        run: |
          set -euo pipefail
          echo "TAG=${GITHUB_SHA::7}" >> $GITHUB_OUTPUT
          ACCOUNT_ID=$(aws sts get-caller-identity --query 'Account' --output text)
          echo "ACCOUNT_ID=$ACCOUNT_ID" >> $GITHUB_OUTPUT
          echo "ECR_REGISTRY=$ACCOUNT_ID.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com" >> $GITHUB_OUTPUT
          echo "ECR_URI=$ACCOUNT_ID.dkr.ecr.${{ secrets.AWS_REGION }}.amazonaws.com/${{ env.IMAGE_NAME }}" >> $GITHUB_OUTPUT

       - name: Ensure ECR repository
        shell: bash
        run: |
          set -euo pipefail
          REPO="${{ env.IMAGE_NAME }}"
          # describe: usa --repository-names (plural)
          aws ecr describe-repositories --repository-names "$REPO" >/dev/null 2>&1 || \
          # create: usa --repository-name (singular)
          aws ecr create-repository --repository-name "$REPO" \
            --image-scanning-configuration scanOnPush=true \
            --encryption-configuration encryptionType=AES256 >/dev/null

      - name: Login to ECR
        shell: bash
        run: |
          aws ecr get-login-password | docker login --username AWS --password-stdin "${{ steps.meta.outputs.ECR_REGISTRY }}"

      - name: Build image
        shell: bash
        run: |
          docker build -t "${{ steps.meta.outputs.ECR_URI }}:${{ steps.meta.outputs.TAG }}" \
                       -t "${{ steps.meta.outputs.ECR_URI }}:latest" .

      - name: Push image
        shell: bash
        run: |
          docker push "${{ steps.meta.outputs.ECR_URI }}:${{ steps.meta.outputs.TAG }}"
          docker push "${{ steps.meta.outputs.ECR_URI }}:latest"

      # ---------- Red: VPC + Subnet pÃºblica ----------
      - name: Discover default VPC + a public subnet
        id: net
        shell: bash
        run: |
          set -euo pipefail
          VPC=$(aws ec2 describe-vpcs --filters Name=isDefault,Values=true --query 'Vpcs[0].VpcId' --output text)
          if [ -z "$VPC" ] || [ "$VPC" = "None" ]; then echo "No default VPC found"; exit 1; fi
          SUBNET=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC Name=map-public-ip-on-launch,Values=true \
                    --query 'Subnets[0].SubnetId' --output text)
          if [ -z "$SUBNET" ] || [ "$SUBNET" = "None" ]; then
            SUBNET=$(aws ec2 describe-subnets --filters Name=vpc-id,Values=$VPC \
                      --query 'Subnets[0].SubnetId' --output text)
          fi
          if [ -z "$SUBNET" ] || [ "$SUBNET" = "None" ]; then echo "Could not find a subnet in VPC $VPC"; exit 1; fi
          echo "VPC=$VPC" >> $GITHUB_OUTPUT
          echo "SUBNET=$SUBNET" >> $GITHUB_OUTPUT

      # ---------- CloudFormation: crea/actualiza la EC2 ----------
      - name: Write CloudFormation template
        shell: bash
        run: |
          cat > /tmp/ec2-ssm-ecr.yml <<'YAML'
          AWSTemplateFormatVersion: '2010-09-09'
          Description: EC2 t2.micro with SSM & ECR read, SG open on 80, public IP.

          Parameters:
            VpcId:
              Type: AWS::EC2::VPC::Id
            SubnetId:
              Type: AWS::EC2::Subnet::Id
            InstanceType:
              Type: String
              Default: t2.micro
              AllowedValues: [t2.micro, t3.micro, t3.small]
            AppTagValue:
              Type: String
              Default: ai-demo

          Resources:
            EC2SSMRole:
              Type: AWS::IAM::Role
              Properties:
                AssumeRolePolicyDocument:
                  Version: '2012-10-17'
                  Statement:
                    - Effect: Allow
                      Principal: { Service: ec2.amazonaws.com }
                      Action: sts:AssumeRole
                ManagedPolicyArns:
                  - arn:aws:iam::aws:policy/AmazonSSMManagedInstanceCore
                  - arn:aws:iam::aws:policy/AmazonEC2ContainerRegistryReadOnly

            EC2InstanceProfile:
              Type: AWS::IAM::InstanceProfile
              Properties:
                Roles: [ !Ref EC2SSMRole ]

            InstanceSG:
              Type: AWS::EC2::SecurityGroup
              Properties:
                GroupDescription: Allow HTTP (80) for ai-demo
                VpcId: !Ref VpcId
                SecurityGroupIngress:
                  - IpProtocol: tcp
                    FromPort: 80
                    ToPort: 80
                    CidrIp: 0.0.0.0/0
                SecurityGroupEgress:
                  - IpProtocol: -1
                    CidrIp: 0.0.0.0/0

            EC2Instance:
              Type: AWS::EC2::Instance
              Properties:
                IamInstanceProfile: !Ref EC2InstanceProfile
                InstanceType: !Ref InstanceType
                ImageId: !Sub "{{resolve:ssm:/aws/service/ami-amazon-linux-latest/al2023-ami-kernel-default-x86_64}}"
                NetworkInterfaces:
                  - DeviceIndex: 0
                    SubnetId: !Ref SubnetId
                    AssociatePublicIpAddress: true
                    GroupSet: [ !Ref InstanceSG ]
                    DeleteOnTermination: true
                Tags:
                  - { Key: Name, Value: !Sub "ai-demo-${AppTagValue}" }
                  - { Key: App,  Value: !Ref AppTagValue }

          Outputs:
            InstanceId:
              Value: !Ref EC2Instance
          YAML

      - name: Create/Update EC2 via CloudFormation
        shell: bash
        run: |
          set -euo pipefail
          aws cloudformation deploy \
            --stack-name "${{ env.STACK_NAME }}" \
            --template-file /tmp/ec2-ssm-ecr.yml \
            --capabilities CAPABILITY_NAMED_IAM \
            --parameter-overrides VpcId=${{ steps.net.outputs.VPC }} SubnetId=${{ steps.net.outputs.SUBNET }} AppTagValue=${{ env.APP_TAG_VALUE }} InstanceType=t2.micro

      # ---------- Descubre la instancia creada (por tag) ----------
      - name: Discover instance by tag (running only)
        id: discover
        shell: bash
        run: |
          set -euo pipefail
          ID=$(aws ec2 describe-instances \
            --filters "Name=instance-state-name,Values=running" \
                      "Name=tag:${{ env.APP_TAG_KEY }},Values=${{ env.APP_TAG_VALUE }}" \
            --query 'Reservations[].Instances[].InstanceId' --output text | head -n1)
          if [ -z "$ID" ] || [ "$ID" = "None" ]; then echo "No running instance found"; exit 1; fi
          echo "INSTANCE_ID=$ID" >> $GITHUB_OUTPUT
          IP=$(aws ec2 describe-instances --instance-ids "$ID" --query 'Reservations[0].Instances[0].PublicIpAddress' --output text)
          echo "PUBLIC_IP=$IP" >> $GITHUB_OUTPUT
          echo "Instance: $ID  IP: $IP"

      - name: Wait for SSM Online
        shell: bash
        run: |
          set -euo pipefail
          ID="${{ steps.discover.outputs.INSTANCE_ID }}"
          for i in $(seq 1 40); do
            PING=$(aws ssm describe-instance-information \
              --filters Key=InstanceIds,Values="$ID" \
              --query 'InstanceInformationList[0].PingStatus' --output text 2>/dev/null || true)
            echo "PingStatus: $PING"
            if [ "$PING" = "Online" ]; then exit 0; fi
            sleep 6
          done
          echo "Instance not Online in SSM"
          exit 1

      # ---------- Despliegue por SSM (sin escapes YAML) ----------
      - name: Deploy via SSM (install docker + run container)
        shell: bash
        run: |
          set -euo pipefail
          REGION="${{ secrets.AWS_REGION }}"
          ECR_REG="${{ steps.meta.outputs.ECR_REGISTRY }}"
          ECR_URI="${{ steps.meta.outputs.ECR_URI }}"
          ID="${{ steps.discover.outputs.INSTANCE_ID }}"
          NAME="${{ env.CONTAINER_NAME }}"
          PORT="${{ env.PORT }}"

          cat > /tmp/ssm-commands.json <<JSON
          {
            "commands": [
              "set -e",
              "if ! command -v docker >/dev/null 2>&1; then sudo dnf -y update || sudo yum -y update; if command -v dnf >/dev/null 2>&1; then sudo dnf -y install docker; else sudo yum -y install docker; fi; sudo systemctl enable --now docker; fi",
              "aws ecr get-login-password --region ${REGION} | sudo docker login --username AWS --password-stdin ${ECR_REG}",
              "sudo systemctl start docker || true",
              "sudo docker pull ${ECR_URI}:latest",
              "sudo docker rm -f ${NAME} || true",
              "sudo docker run -d --name ${NAME} -p ${PORT}:8080 ${ECR_URI}:latest",
              "curl -s http://localhost/health || true"
            ]
          }
          JSON

          CMD_ID=$(aws ssm send-command \
            --instance-ids "$ID" \
            --document-name "AWS-RunShellScript" \
            --comment "Deploy ${ECR_URI}:latest" \
            --parameters file:///tmp/ssm-commands.json \
            --query 'Command.CommandId' --output text)
          echo "CMD_ID=$CMD_ID"

          for i in $(seq 1 40); do
            STATUS=$(aws ssm list-command-invocations --command-id "$CMD_ID" --details \
              --query 'CommandInvocations[0].Status' --output text 2>/dev/null || true)
            echo "SSM status: $STATUS"
            if [ "$STATUS" = "Success" ]; then break; fi
            if echo "$STATUS" | grep -E -q 'Cancelled|Failed|TimedOut'; then
              echo "SSM command failed: $STATUS"
              exit 1
            fi
            sleep 5
          done

      # ---------- Health externo ----------
      - name: External health check
        shell: bash
        run: |
          set -euo pipefail
          IP="${{ steps.discover.outputs.PUBLIC_IP }}"
          for i in $(seq 1 30); do
            CODE=$(curl -s -o /dev/null -w '%{http_code}' "http://$IP/health" || true)
            echo "health http_code=$CODE"
            if [ "$CODE" = "200" ]; then
              echo "App disponible en: http://$IP/"
              exit 0
            fi
            sleep 3
          done
          echo "Service not healthy on $IP"
          exit 1
